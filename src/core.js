// Generated by CoffeeScript 1.8.0
(function() {
  var ColumnVector, IdentityMatrix, Matrix, OnesMatrix, Regression,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  if (global.S === void 0) {
    global.S = {};
  }

  Matrix = (function() {
    function Matrix(mtx) {
      this.mtx = mtx;
      this.height = this.mtx.length;
      this.width = this.mtx[0].length;
    }

    Matrix.prototype.transposed = function() {
      var i, j, trans, _i, _j, _ref, _ref1;
      trans = [];
      for (i = _i = 0, _ref = this.width - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        trans[i] = [];
        for (j = _j = 0, _ref1 = this.height - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          trans[i][j] = this.mtx[j][i];
        }
      }
      return new Matrix(trans);
    };

    Matrix.prototype.mult = function(other) {
      var c, k, r, result, sum, _i, _j, _k, _ref, _ref1, _ref2;
      if (this.width !== other.height) {
        throw "error: incompatible";
      }
      result = [];
      for (r = _i = 0, _ref = this.height - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; r = 0 <= _ref ? ++_i : --_i) {
        result[r] = [];
        for (c = _j = 0, _ref1 = other.width - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; c = 0 <= _ref1 ? ++_j : --_j) {
          sum = 0;
          for (k = _k = 0, _ref2 = this.width - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; k = 0 <= _ref2 ? ++_k : --_k) {
            sum += this.mtx[r][k] * other.mtx[k][c];
          }
          result[r][c] = sum;
        }
      }
      return new Matrix(result);
    };

    Matrix.prototype.exp = function(n) {
      var i, result, _i;
      if (this.width !== this.height) {
        throw "error: incompatible";
      }
      result = new IdentityMatrix(this.height);
      for (i = _i = 1; 1 <= n ? _i <= n : _i >= n; i = 1 <= n ? ++_i : --_i) {
        result = result.mult(this);
      }
      return result;
    };

    Matrix.prototype.pow = function(n) {
      var i, j, res, _i, _j, _ref, _ref1;
      res = [];
      for (i = _i = 0, _ref = this.height - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        res[i] = [];
        for (j = _j = 0, _ref1 = this.width - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          res[i][j] = Math.pow(this.mtx[i][j], n);
        }
      }
      return new Matrix(res);
    };

    Matrix.prototype.toReducedRowEchelonForm = function() {
      var i, j, lead, r, tmp, val, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3;
      lead = 0;
      for (r = _i = 0, _ref = this.height - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; r = 0 <= _ref ? ++_i : --_i) {
        if (this.width <= lead) {
          return;
        }
        i = r;
        while (this.mtx[i][lead] === 0) {
          i += 1;
          if (i === this.height) {
            i = r;
            lead += 1;
            if (lead === this.width) {
              return;
            }
          }
        }
        tmp = this.mtx[i];
        this.mtx[i] = this.mtx[r];
        this.mtx[r] = tmp;
        val = this.mtx[r][lead];
        for (j = _j = 0, _ref1 = this.width - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          this.mtx[r][j] /= val;
        }
        for (i = _k = 0, _ref2 = this.height - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
          if (i === r) {
            continue;
          }
          val = this.mtx[i][lead];
          for (j = _l = 0, _ref3 = this.width - 1; 0 <= _ref3 ? _l <= _ref3 : _l >= _ref3; j = 0 <= _ref3 ? ++_l : --_l) {
            this.mtx[i][j] -= val * this.mtx[r][j];
          }
        }
        lead += 1;
      }
      return this;
    };

    Matrix.prototype.inverse = function() {
      var res;
      res = new Matrix(this.mtx);
      res.invert();
      return res;
    };

    Matrix.prototype.invert = function() {
      var I, i, _i, _j, _ref, _ref1;
      if (this.width !== this.height) {
        throw "error: no inverse for non-square matrix";
      }
      I = new IdentityMatrix(this.height);
      for (i = _i = 0, _ref = this.height - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.mtx[i] = this.mtx[i].concat(I.mtx[i]);
      }
      this.width *= 2;
      this.toReducedRowEchelonForm();
      for (i = _j = 0, _ref1 = this.height - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        this.mtx[i].splice(0, this.height);
      }
      this.width /= 2;
      return this;
    };

    Matrix.prototype.subtract = function(other) {
      var i, j, res, _i, _j, _ref, _ref1;
      if ((this.width !== other.width) || (this.height !== other.height)) {
        throw "error: incompatible";
      }
      res = [];
      for (i = _i = 0, _ref = this.height - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        res[i] = [];
        for (j = _j = 0, _ref1 = this.width - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          res[i][j] = this.mtx[i][j] - other.mtx[i][j];
        }
      }
      return new Matrix(res);
    };

    Matrix.prototype.add = function(other) {
      var i, j, res, _i, _j, _ref, _ref1;
      if ((this.width !== other.width) || (this.height !== other.height)) {
        throw "error: incompatible";
      }
      res = [];
      for (i = _i = 0, _ref = this.height - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        res[i] = [];
        for (j = _j = 0, _ref1 = this.width - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          res[i][j] = this.mtx[i][j] + other.mtx[i][j];
        }
      }
      return new Matrix(res);
    };

    Matrix.prototype.div = function(n) {
      var i, j, res, _i, _j, _ref, _ref1;
      res = [];
      for (i = _i = 0, _ref = this.height - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        res[i] = [];
        for (j = _j = 0, _ref1 = this.width - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          res[i][j] = this.mtx[i][j] / n;
        }
      }
      return new Matrix(res);
    };

    Matrix.prototype.smult = function(n) {
      var i, j, res, _i, _j, _ref, _ref1;
      res = [];
      for (i = _i = 0, _ref = this.height - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        res[i] = [];
        for (j = _j = 0, _ref1 = this.width - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          res[i][j] = this.mtx[i][j] * n;
        }
      }
      return new Matrix(res);
    };

    Matrix.prototype.colmeans = function(df) {
      var i, j, means, _i, _j, _ref, _ref1;
      if (df == null) {
        df = 0;
      }
      means = [];
      for (i = _i = 0, _ref = this.height - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        for (j = _j = 0, _ref1 = this.width - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          if (means[j] === void 0) {
            means[j] = this.mtx[i][j];
          } else {
            means[j] += this.mtx[i][j];
          }
        }
      }
      return new Matrix([means]).div(this.height - df);
    };

    return Matrix;

  })();

  ColumnVector = (function(_super) {
    __extends(ColumnVector, _super);

    function ColumnVector(array) {
      ColumnVector.__super__.constructor.call(this, array.map(function(v) {
        return [v];
      }));
    }

    return ColumnVector;

  })(Matrix);

  IdentityMatrix = (function(_super) {
    __extends(IdentityMatrix, _super);

    function IdentityMatrix(n) {
      var i, j, _i, _j, _ref, _ref1;
      this.height = n;
      this.width = n;
      this.mtx = [];
      for (i = _i = 0, _ref = n - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.mtx[i] = [];
        for (j = _j = 0, _ref1 = n - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          this.mtx[i][j] = i === j ? 1 : 0;
        }
      }
    }

    return IdentityMatrix;

  })(Matrix);

  OnesMatrix = (function(_super) {
    __extends(OnesMatrix, _super);

    function OnesMatrix(height, width) {
      var i, j, res, _i, _j, _ref, _ref1;
      if (width === void 0) {
        width = height;
      }
      res = [];
      for (i = _i = 0, _ref = height - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        res[i] = [];
        for (j = _j = 0, _ref1 = width - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          res[i][j] = 1;
        }
      }
      OnesMatrix.__super__.constructor.call(this, res);
    }

    return OnesMatrix;

  })(Matrix);

  Regression = (function() {
    function Regression(y, X) {
      this.y = y;
      this.X = X;
    }

    Regression.prototype.run = function() {
      var XB, XXinverse, X_t, n, y_t;
      X_t = this.X.transposed();
      XXinverse = X_t.mult(this.X).inverse();
      this.B = XXinverse.mult(X_t).mult(this.y);
      XB = this.X.mult(this.B);
      this.e = this.y.subtract(XB);
      this.sigma2 = this.e.pow(2).colmeans(this.X.width).mtx[0][0];
      this.varCovar = XXinverse.smult(this.sigma2);
      this.H = this.X.mult(XXinverse).mult(X_t);
      n = this.y.height;
      y_t = this.y.transposed();
      this.SSr = y_t.mult(this.H.subtract(new OnesMatrix(n).smult(1.0 / n))).mult(this.y).mtx[0][0];
      this.dof = this.X.width - 1;
      this.MSr = this.SSr / this.dof;
      this.SSe = y_t.mult(new IdentityMatrix(n).subtract(this.H)).mult(this.y).mtx[0][0];
      this.MSe = this.SSe / (n - (this.dof + 1));
      return this.f0 = this.MSr / this.MSe;
    };

    return Regression;

  })();

  S.Matrix = Matrix;

  S.ColumnVector = ColumnVector;

  S.IdentityMatrix = IdentityMatrix;

  S.Regression = Regression;

}).call(this);
