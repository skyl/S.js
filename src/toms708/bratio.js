// Generated by CoffeeScript 1.8.0
(function() {
  var Bratio, apser, exparg, fpser, geteps, ipmpar, max, min, psi, spmpar, sw;

  geteps = function() {
    return 0.0000000000000001;
  };

  min = function(a, b) {
    if (a < b) {
      return a;
    } else {
      return b;
    }
  };

  max = function(a, b) {
    if (a > b) {
      return a;
    } else {
      return b;
    }
  };

  sw = function(a, b) {
    return [b, a];
  };


  /*
  IMACH = [
  ]
   */

  ipmpar = function(i) {
    switch (i) {
      case 1:
        return 2;
      case 2:
        return 31;
      case 3:
        return 2147483647;
      case 4:
        return 2;
      case 5:
        return 24;
      case 6:
        return -125;
      case 7:
        return 128;
      case 8:
        return 53;
    }
    throw "called impar with invalid argument, " + i;
  };

  spmpar = function(i) {

    /*
          function spmpar ( i )
    
    c*********************************************************************72
    c
    cc SPMPAR returns single precision real machine constants.
    c
    C     SPMPAR PROVIDES THE SINGLE PRECISION MACHINE CONSTANTS FOR
    C     THE COMPUTER BEING USED. IT IS ASSUMED THAT THE ARGUMENT
    C     I IS AN INTEGER HAVING ONE OF THE VALUES 1, 2, OR 3. IF THE
    C     SINGLE PRECISION ARITHMETIC BEING USED HAS M BASE B DIGITS AND
    C     ITS SMALLEST AND LARGEST EXPONENTS ARE EMIN AND EMAX, THEN
    C
    C        SPMPAR(1) = B**(1 - M), THE MACHINE PRECISION,
    C
    C        SPMPAR(2) = B**(EMIN - 1), THE SMALLEST MAGNITUDE,
    C
    C        SPMPAR(3) = B**EMAX*(1 - B**(-M)), THE LARGEST MAGNITUDE.
     */
    var b, binv, bm1, emax, emin, m, one, w, z;
    one = parseFloat(1);
    if (i <= 1) {
      b = ipmpar(4);
      m = ipmpar(5);
      return Math.pow(b, 1 - m);
    }
    if (i <= 2) {
      b = ipmpar(4);
      emin = ipmpar(6);
      binv = one / b;
      w = Math.pow(b, emin / 2);
      return ((w * binv) * binv) * binv;
    } else {
      m = ipmpar(5);
      emax = ipmpar(7);
      b = ibeta;
      bm1 = ibeta - 1;
      z = Math.pow(b, m - 1);
      w = ((z - one) * b + bm1) / (b * z);
      z = Math.pow(b, emax - 2);
      return ((w * z) * b) * b;
    }
  };

  exparg = function(l) {
    var b, lnb, m;
    b = ipmpar(4);
    switch (b) {
      case 2:
        lnb = 0.69314718055995;
        break;
      case 8:
        lnb = 2.0794415416798;
        break;
      case 16:
        lnb = 2.7725887222398;
        break;
      default:
        lnb = Math.log(b);
    }
    if (l !== 0) {
      m = ipmpar(6) - 1;
    } else {
      m = ipmpar(7);
    }
    return 0.99999 * (m * lnb);
  };

  fpser = function(a, b, x, eps) {
    var an, c, ret, s, t, tol;
    ret = 1.0;
    if (a < (0.001 * eps)) {

    } else {
      ret = 0;
      t = a * Math.log(x);
      if (t < exparg(1)) {
        return ret;
      }
      ret = Math.exp(t);
    }
    ret = (b / a) * ret;
    tol = eps / a;
    an = a + 1.0;
    t = x;
    s = t / an;
    c = t / an;
    while (Math.abs(c) > tol) {
      t = x * t;
      c = t / an;
      s = s + c;
    }
    ret = ret * (1.0 + a * s);
    return ret;
  };

  apser = function(a, b, x, eps) {

    /*
    cc APSER evaluates I(1-X)(B,A) for A very small.
    c
    C     APSER YIELDS THE INCOMPLETE BETA RATIO I(SUB(1-X))(B,A) FOR
    C     A .LE. MIN(EPS,EPS*B), B*X .LE. 1, AND X .LE. 0.5. USED WHEN
    C     A IS VERY SMALL. USE ONLY IF ABOVE INEQUALITIES ARE SATISFIED.
    C
     */
    var aj, bx, c, g, j, s, t, tol;
    g = 0.577215664901533;
    bx = b * x;
    t = x - bx;
    if ((b * eps) > 2e-2) {
      c = Math.log(bx) + g + t;
    } else {
      c = Math.log(x) + psi(b) + g + t;
    }
    tol = 5.0 * eps * Math.abs(c);
    j = 1.0;
    s = 0.0;
    aj = 0;
    g = function() {
      j = j + 1;
      t = t * (x - bx / j);
      aj = t / j;
      return s = s + aj;
    };
    g();
    while (Math.abs(aj) > tol) {
      g();
    }
    return -a * (c + s);
  };

  psi = function(X) {

    /*
          function psi ( xx )
    
    c*********************************************************************72
    C
    cc PSI evaluates the Digamma function.
    c
    C
    C     PSI(XX) IS ASSIGNED THE VALUE 0 WHEN THE DIGAMMA FUNCTION CANNOT
    C     BE COMPUTED.
    C
    C     THE MAIN COMPUTATION INVOLVES EVALUATION OF RATIONAL CHEBYSHEV
    C     APPROXIMATIONS PUBLISHED IN MATH. COMP. 27, 123-127(1973) BY
    C     CODY, STRECOK AND THACHER.
    C
    C
    C     PSI WAS WRITTEN AT ARGONNE NATIONAL LABORATORY FOR THE FUNPACK
    C     PACKAGE OF SPECIAL FUNCTION SUBROUTINES. PSI WAS MODIFIED BY
    C     A.H. MORRIS (NSWC).
    C
     */
    var AUG, DEN, DX0, I, M, N, NQ, P1, P2, PIOV4, Q1, Q2, SGN, UPPER, W, XMAX1, XMX0, XSMALL, Z, _i, _j;
    if (X === 0.0) {
      return 0;
    }
    PIOV4 = 0.785398163397448;
    DX0 = 1.461632144968362341262659542325721325;
    P1 = [0.895385022981970e-02, 0.477762828042627e+01, 0.142441585084029e+03, 0.118645200713425e+04, 0.363351846806499e+04, 0.413810161269013e+04, 0.130560269827897e+04];
    Q1 = [0.448452573429826e+02, 0.520752771467162e+03, 0.221000799247830e+04, 0.364127349079381e+04, 0.190831076596300e+04, 0.691091682714533e-05];
    P2 = [-0.212940445131011e+01, -0.701677227766759e+01, -0.448616543918019e+01, -0.648157123766197e+00];
    Q2 = [0.322703493791143e+02, 0.892920700481861e+02, 0.546117738103215e+02, 0.777788548522962e+01];
    XMAX1 = ipmpar(3);
    XMAX1 = min(XMAX1, 1.0 / spmpar(1));
    XSMALL = 1.0e-9;
    AUG = 0.0;
    if (X >= 0.5) {

    } else {
      if (Math.abs(X) > XSMALL) {
        W = -X;
        SGN = PIOV4;
        if (W <= 0.0) {
          W = -W;
          SGN = -SGN;
        }
        if (W >= XMAX1) {
          return 0;
        }
        NQ = Math.parseInt(W);
        W = W - Math.parseFloat(NQ);
        NQ = Math.parseInt(W * 4.0);
        W = 4.0 * (W = Math.parseFloat(NQ) * 0.25);

        /*
        C
        C  W IS NOW RELATED TO THE FRACTIONAL PART OF  4.0 * X.
        C  ADJUST ARGUMENT TO CORRESPOND TO VALUES IN FIRST
        C  QUADRANT AND DETERMINE SIGN
        C
         */
        N = NQ / 2;
        if ((N + N) !== NQ) {
          W = 1.0 - W;
        }
        Z = PIOV4 * W;
        if (Z === 0.0) {
          return 0;
        }
        M = N / 2;
        if ((M + M) !== N) {
          SGN = -SGN;
        }
        N = (NQ + 1) / 2;
        M = N / 2;
        M = M + M;
        if (M !== N) {
          AUG = SGN * (Math.sin(Z) / Math.cos(Z)) * 4.0;
        } else {
          AUG = SGN * (Math.cos(Z) / Math.sin(Z)) * 4.0;
        }
      } else {

        /*
        C
        C  0 < ABS(X) < XSMALL.  USE 1/X AS A SUBSTITUTE
        C  FOR  PI*COTAN(PI*X)
        C
         */
        AUG = -1.0 / X;
      }
      X = 1.0 - X;
    }
    if (X <= 3.0) {
      DEN = X;
      UPPER = P1[0] * X;
      for (I = _i = 0; _i <= 4; I = ++_i) {
        DEN = (DEN + Q1[I]) * X;
        UPPER = (UPPER + P1[I + 1]) * X;
      }
      DEN = (UPPER + P1[6]) / (DEN + Q1[5]);
      XMX0 = parseFloat(X) - DX0;
      return DEN * XMX0 + AUG;
    }
    if (X < XMAX1) {
      W = 1.0 / (X * X);
      DEN = W;
      UPPER = P2[0] * W;
      for (I = _j = 0; _j <= 2; I = ++_j) {
        DEN = (DEN + Q2[I]) * W;
        UPPER = (UPPER + P2[I + 1]) * W;
      }
      AUG = UPPER / (DEN + Q2[3]) - 0.5 / X + AUG;
    }
    return AUG + Math.log(X);
  };

  Bratio = (function() {
    function Bratio(x, a, b) {
      this.x = x;
      this.a = a;
      this.b = b;
      this.y = 1 - this.x;
      this.handle_errors();
      this.eps = geteps();
      this.ind = 0;
      this.getlambda();
    }

    Bratio.prototype.handle_errors = function() {
      if ((this.a < 0) || (this.b < 0)) {
        throw "a and b must be greater than or equal to 0";
      }
      if ((this.a === 0) && (this.b === 0)) {
        throw "a and b cannot both be zero";
      }
      if ((this.x < 0) || (this.x > 1)) {
        throw "x must not be less than 0 or greater than 1";
      }
      if ((this.y < 0) || (this.y > 1)) {
        throw "y (1 - x) must not be less than 0 or greater than 1";
      }
    };

    Bratio.prototype.getlambda = function() {
      var _ref, _ref1;
      if (this.a > this.b) {
        this.lambda = (this.a + this.b) * this.y - this.b;
      } else {
        this.lambda = this.a - (this.a + this.b) * this.x;
      }
      if (this.lambda < 0) {
        console.log("32 LAMBDA<0");
        this.ind = 1;
        console.log(this.a, this.b);
        _ref = sw(this.a, this.b), this.b = _ref[0], this.a = _ref[1];
        console.log(this.a, this.b);
        _ref1 = sw(this.x, this.y), this.y = _ref1[0], this.x = _ref1[1];
        return this.lambda = Math.abs(this.lambda);
      }
    };

    Bratio.prototype.getw = function() {
      var _ref, _ref1;
      if ((this.a > 1) && (this.b > 1)) {
        return proc_a_gt_1_and_b_gt_1();
      } else {
        if (this.x > 0.5) {
          this.ind = 1;
          _ref = sw(this.b, this.a), this.a = _ref[0], this.b = _ref[1];
          _ref1 = sw(this.y, this.x), this.x = _ref1[0], this.y = _ref1[1];
        }
        if (this.b < min(this.eps, this.eps * this.a)) {
          this.w = fpser(this.a, this.b, this.x, this.eps);
          this.goto220();
          return this.w;
        }
        if ((this.a < min(this.eps, this.eps * this.b)) && (this.b * this.x <= 1.0) && (this.x <= 0.5)) {
          this.w = apser(this.a, this.b, this.x, this.eps);
          this.goto220();
          return this.w;
        }
      }

      /*
       40 IF (B0 .LT. 40.0 .AND. B0*X0 .LE. 0.7) GO TO 100
          IF (B0 .LT. 40.0) GO TO 140
          IF (A0 .GT. B0) GO TO 50
             IF (A0 .LE. 100.0) GO TO 120
             IF (LAMBDA .GT. 0.03*A0) GO TO 120
             GO TO 180
       50 IF (B0 .LE. 100.0) GO TO 120
          IF (LAMBDA .GT. 0.03*B0) GO TO 120
          GO TO 180
       */
    };

    Bratio.prototype.goto220 = function() {
      if (this.ind === 0) {

      } else {
        return this.w = 1 - this.w;
      }
    };

    Bratio.prototype.proc_a_gt_1_and_b_gt_1 = function() {};

    return Bratio;

  })();

  if (global.S === void 0) {
    global.S = {};
  }

  S.Bratio = Bratio;

  S.fpser = fpser;

  S.apser = apser;

  S.psi = psi;

}).call(this);
