// Generated by CoffeeScript 1.7.1
(function() {
  var assert, expect, id_3_by_3, inverted, invertible, matrix, matrix_example, matrix_example_10, matrix_for_reduction, matrix_for_reduction2, matrix_reduced, matrix_reduced2, matrix_reduced3, mult_result, other, trans, _ref;

  _ref = require("chai"), expect = _ref.expect, assert = _ref.assert;

  require("../src/core.js");

  matrix = [[1, 2, 3], [4, 5, 6]];

  trans = [[1, 4], [2, 5], [3, 6]];

  other = [[0, 0], [1, 1], [2, 2]];

  mult_result = [[8, 8], [17, 17]];

  id_3_by_3 = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];

  matrix_example = [[3, 2], [2, 1]];

  matrix_example_10 = [[1346269, 832040], [832040, 514229]];

  matrix_for_reduction = [[1, 3, -1], [0, 1, 7]];

  matrix_reduced = [[1, 0, -22], [0, 1, 7]];

  matrix_for_reduction2 = [[1, 2, -1, -4], [2, 3, -1, -11], [-2, 0, -3, 22]];

  matrix_reduced2 = [[1, 0, 0, -8], [0, 1, 0, 1], [0, 0, 1, -2]];

  matrix_reduced3 = [[1, 0, 0, -8], [0, 1, 0, 1], [0, 0, 1, -2]];

  invertible = [[1, 0, 10], [0, 1, 5], [0, 0, 5]];

  inverted = [[1, 0, -2], [0, 1, -1], [0, 0, 0.2]];

  describe("S.Matrix", function() {
    it(".transpose() should return transposed Matrix", function() {
      var m, m2;
      m = new S.Matrix(matrix);
      m2 = m.transposed();
      return expect(m2.mtx).to.deep.equal(trans);
    });
    it(".mult(other) throws error for incompatible", function() {
      var f, m, m2;
      m = new S.Matrix(trans);
      m2 = new S.Matrix(other);
      f = function() {
        var m3;
        return m3 = m.mult(m2);
      };
      return expect(f).to["throw"]("error: incompatible");
    });
    it(".mult(other) returns the correct result", function() {
      var m, m2, m3;
      m = new S.Matrix(matrix);
      m2 = new S.Matrix(other);
      m3 = m.mult(m2);
      return expect(m3.mtx).to.deep.equal(mult_result);
    });
    it(".exp(n) throws error for non-square", function() {
      var f, m;
      m = new S.Matrix(trans);
      f = function() {
        return m.exp(10);
      };
      return expect(f).to["throw"]("error: incompatible");
    });
    it(".exp(10) gives correct answer", function() {
      var m, m2;
      m = new S.Matrix(matrix_example);
      m2 = m.exp(10);
      return expect(m2.mtx).to.be.deep.equal(matrix_example_10);
    });
    it(".pow(n) returns the correct values", function() {
      var m, m2;
      m = new S.Matrix([[1, 2, 3], [4, 5, 6]]);
      m2 = m.pow(2);
      return expect(m2.mtx).to.be.deep.equal([[1, 4, 9], [16, 25, 36]]);
    });
    it(".toReducedRowEchelonForm makes correct matrix 1", function() {
      var m;
      m = new S.Matrix(matrix_for_reduction);
      m.toReducedRowEchelonForm();
      return expect(m.mtx).to.be.deep.equal(matrix_reduced);
    });
    it(".toReducedRowEchelonForm makes correct matrix 2", function() {
      var i, j, m, _i, _ref1, _results;
      m = new S.Matrix(matrix_for_reduction2);
      m.toReducedRowEchelonForm();
      _results = [];
      for (i = _i = 0, _ref1 = m.height - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref2, _results1;
          _results1 = [];
          for (j = _j = 0, _ref2 = m.width - 1; 0 <= _ref2 ? _j <= _ref2 : _j >= _ref2; j = 0 <= _ref2 ? ++_j : --_j) {
            _results1.push(assert(m.mtx[i][j] === matrix_reduced2[i][j]));
          }
          return _results1;
        })());
      }
      return _results;
    });
    it(".invert() throws error for non-square", function() {
      var f, m;
      m = new S.Matrix(matrix);
      f = function() {
        return m.inverse();
      };
      return expect(f).to["throw"]("error: no inverse for non-square matrix");
    });
    it(".inverse() returns correct value", function() {
      var m, m2;
      m = new S.Matrix(invertible);
      m2 = m.inverse();
      return expect(m2.mtx).to.be.deep.equal(inverted);
    });
    it(".subtract(other) returns correct value", function() {
      var m, m2;
      m = new S.Matrix([[1, 2, 4]]);
      m2 = new S.Matrix([[0, 2, 3]]);
      return expect(m.subtract(m2).mtx).to.be.deep.equal([[1, 0, 1]]);
    });
    return it(".add(other) returns correct matrix", function() {
      var m1, m2, m3;
      m1 = new S.Matrix([[1, 2, 3], [9, 8, 7]]);
      m2 = new S.Matrix([[0.5, 1.5, 2.5], [3.5, 4.5, 5.5]]);
      m3 = m1.add(m2);
      return expect(m3.mtx).to.be.deep.equal([[1.5, 3.5, 5.5], [12.5, 12.5, 12.5]]);
    });
  });

  describe("S.IdentityMatrix", function() {
    return it("constructor produces correct matrix", function() {
      var m;
      m = new S.IdentityMatrix(3);
      return expect(m.mtx).to.be.deep.equal(id_3_by_3);
    });
  });

  describe("Basic Regression", function() {
    var X, coeff, y;
    y = new S.ColumnVector([52.21, 53.12, 54.48, 55.84, 57.20, 58.57, 59.93, 61.29, 63.11, 64.47, 66.28, 68.10, 69.92, 72.19, 74.46]);
    X = new S.Matrix([1.47, 1.50, 1.52, 1.55, 1.57, 1.60, 1.63, 1.65, 1.68, 1.70, 1.73, 1.75, 1.78, 1.80, 1.83].map(function(v) {
      return [Math.pow(v, 0), Math.pow(v, 1), Math.pow(v, 2)];
    }));
    coeff = new S.ColumnVector([128.8128035798277, -143.1620228653037, 61.960325442985436]);
    it(".regression_coefficients() are correct", function() {
      var regression;
      regression = new S.Regression(y, X);
      regression.run();
      expect(regression.B.mtx).to.be.deep.equal(coeff.mtx);
      return expect(y.mtx).to.be.deep.equal(X.mult(regression.B).add(regression.e).mtx);
    });
    return it(".regression_coefficients() are correct simple", function() {
      var e, regression;
      y = new S.ColumnVector([50, 60, 70, 80, 90, 100]);
      X = new S.Matrix([[1, 50], [1, 60], [1, 70], [1, 80], [1, 90], [1, 100]]);
      regression = new S.Regression(y, X);
      regression.run();
      e = 0.00000001;
      expect(regression.B.mtx[0][0]).to.be.closeTo(0, e);
      return expect(regression.B.mtx[1][0]).to.be.closeTo(1, e);
    });
  });

  describe("Multiple Linear Regression Analysis", function() {
    var B, X, outcome, regression, varcovarMat;
    outcome = new S.ColumnVector([251.3, 251.3, 248.3, 267.5, 273.0, 276.5, 270.3, 274.9, 285.0, 290.0, 297.0, 302.5, 304.5, 309.3, 321.7, 330.7, 349.0]);
    X = new S.Matrix([[1, 41.9, 29.1], [1, 43.4, 29.3], [1, 43.9, 29.5], [1, 44.5, 29.7], [1, 47.3, 29.9], [1, 47.5, 30.3], [1, 47.9, 30.5], [1, 50.2, 30.7], [1, 52.8, 30.8], [1, 53.2, 30.9], [1, 56.7, 31.5], [1, 57.0, 31.7], [1, 63.5, 31.9], [1, 65.3, 32.0], [1, 71.1, 32.1], [1, 77.0, 32.5], [1, 77.8, 32.9]]);
    regression = new S.Regression(outcome, X);
    regression.run();
    B = [-153.51, 1.24, 12.08];
    it("regression analysis produces correct coefficients", function() {
      var i, _i, _ref1, _results;
      _results = [];
      for (i = _i = 0, _ref1 = regression.B.mtx[0].length - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        _results.push(expect(regression.B.mtx[0][i]).to.be.closeTo(B[i], 0.1));
      }
      return _results;
    });
    varcovarMat = new S.Matrix([[10176.7446, 37.1445, -395.8261], [37.1445, 0.1557, -1.481], [-395.8261, -1.481, 15.4629]]);
    return it("regression analysis produces correct var/covar matrix", function() {
      var i, j, vcvM, _i, _ref1, _results;
      vcvM = regression.varCovar;
      _results = [];
      for (i = _i = 0, _ref1 = vcvM.height - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref2, _results1;
          _results1 = [];
          for (j = _j = 0, _ref2 = vcvM.width - 1; 0 <= _ref2 ? _j <= _ref2 : _j >= _ref2; j = 0 <= _ref2 ? ++_j : --_j) {
            _results1.push(expect(vcvM.mtx[i][j]).to.be.closeTo(varcovarMat.mtx[i][j], 0.001));
          }
          return _results1;
        })());
      }
      return _results;
    });
  });

}).call(this);
